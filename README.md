# **[Dungeon Crawler 3000](https://tfraczak.github.io/dungeon_crawler/)**

*[Dungeon Crawler 3000](https://tfraczak.github.io/dungeon_crawler/) is a JavaScript browser game where a player can explore a randomly generated dungeon.*

---

### Functionality & MVP

In Dungeon Crawler 3000, players will be able to:

游릭 Move their character around on the screen.  
游릭 Animate sprite's movement.  
游릭 Move from one randomized room node to another.  
游릭 Interact with entities (ex. items such as coins, potions... etc.).  
  - 游릭 First implementation will be coins.  

游릭 Interactive enemies with their own pathfinding logic.  
游댮 BONUS - Additional items, such as health potions or stamina regeneratives.  
游댮 BONUS - Battle logic for the player to attack enemies.  
游댮 BONUS - Implement different classes for the player to choose from the start.  
游댮 BONUS - Implement a simple, yet complex, character attribute system that will affect how the player's character performs in the game.  

In addition, this project will include:

- Graphics generated by RPG Maker MV.
- Animated sprites.
- A graph node tree to keep track of the rooms the player has explored.

Technologies employed

- JavaScript
  - JavaScript is the modern web's workhorse when it comes to driving almost anything on the internet nowadays. One of the appealing aspects of the language is the versatility of it, especially with built-in DOM manipulation, and context setting functions (bind, call, apply).
- NodeJS for installing packages such as webpack, babel, css/scss loaders
  - In this project, Node was only used for installing libraries (like webpack, css/scss loader, ES translators... etc) used for packaging the final product.
- HTML/CSS/Sass
  - Another important family of coding languages critical to how we visualize and interact with modern webpages. HTML has the building blocks for creating skeletons for webpages. CSS executes all of our aesthetic dreams and designs. And finally, Sass just makes CSS a whole lot easier with it being a pre-processing language for CSS with added features that facilitate ease of styling.
- Canvas
  - Finally, the last, and most important technology of this project, canvas. This API allows for pure JS-based games in the browser. Nothing more, or less, is needed to easily execute all of our game-designing dreams. It incorporates JavaScript's vanilla DOM manipulation, as well as its own library, to render to a single DOM element, smoothly animated images that could rival some modern day games.

Feature Highlights
[Dungeon Crawler 3000](https://tfraczak.github.io/dungeon_crawler/) implements a randomly generated graph node system, to generate and keep track of rooms within the game. Each play through is different from the last. Can you find all of the extremely rare single path rooms? 
<img src="https://github.com/tfraczak/dungeon_crawler/blob/main/design_docs/room_nodes.gif?raw=true" />

Another feature I'm pretty proud of is the implementation of a collision box class that is attached to an entity. All collision calculations are based on the size and shape of the collision box, instead of the entire area of the sprite. This ensures an enhanced UI/UX such that the player can reliably know that they've been hit by an enemy and not guess so much where the collision detection starts and ends. The collision box is centered mainly around the feet of the character sprite as seen below.  
<img src="https://github.com/tfraczak/dungeon_crawler/blob/main/design_docs/col_box.png?raw=true" />  
The main challenge I faced with implementing this strategy is that it requires a lot of bookkeeping in the form of variables. Even if one element in one array is off, it throws off the entire interactive nature of the collision box, which would allow players to wedge themselves through walls and the like.

Here is a snippet just calcuating if one side is in contact with another object's opposing side:

```javascript
export const collidedWithSide = (side, thisSide, otherSide) => {
  let collided = false;
  let upperDiff, lowerDiff;
  const upperBounds = 10;
  const lowerBounds = 0;
  if (side === "top" || side === "bottom") {
    const thisYVal = thisSide[1];
    const [thisXMin, thisXMax] = thisSide[0];
    const otherYVal = otherSide[1];
    const [otherXMin, otherXMax] = otherSide[0];
    
    switch (side) {
      case "top":
        upperDiff = (otherYVal - thisYVal) < upperBounds;
        lowerDiff = (otherYVal - thisYVal) > lowerBounds;
        collided = 
          (thisYVal < otherYVal) &&
          (thisXMin < otherXMax) &&
          (thisXMax > otherXMin) &&
          upperDiff && lowerDiff;
        break;
      case "bottom":
        upperDiff = (thisYVal - otherYVal) < upperBounds;
        lowerDiff = (thisYVal - otherYVal) > lowerBounds;
        collided = 
          (thisYVal > otherYVal) &&
          (thisXMin < otherXMax) &&
          (thisXMax > otherXMin) &&
          upperDiff && lowerDiff;
        break;
      default:
        break;
    }

    if (collided) return otherYVal;

  } else {
    const thisXVal = thisSide[0];
    const [thisYMin, thisYMax] = thisSide[1];
    const otherXVal = otherSide[0];
    const [otherYMin, otherYMax] = otherSide[1];
    
    switch (side) {
      case "left":
        upperDiff = (otherXVal - thisXVal) < upperBounds;
        lowerDiff = (otherXVal - thisXVal) > lowerBounds;
        collided = 
          (thisXVal < otherXVal) &&
          (thisYMin < otherYMax) &&
          (thisYMax > otherYMin) &&
          upperDiff && lowerDiff;
          break;
      case "right":
        upperDiff = (thisXVal - otherXVal) < upperBounds;
        lowerDiff = (thisXVal - otherXVal) > lowerBounds;
        collided = 
          (thisXVal > otherXVal) &&
          (thisYMin < otherYMax) &&
          (thisYMax > otherYMin) &&
          upperDiff && lowerDiff;
          break;
      default:
        break;
    }

    if (collided) return otherXVal;
    
  }

  return false;

};
```
As you can see, this is just one piece of a huge machine that figures out if objects are touching. This particular code checks if a side of one object is either touching, or just beyond the other object's side. And this also is dynamic enough to account for whether it's a left meeting a right, a bottom meeting a top... etc.

Other images from the app:

This game is pretty difficult!  
<img src="https://github.com/tfraczak/dungeon_crawler/blob/main/design_docs/game_over.gif?raw=true" />  
Hover effects and canvas effects of the game start portion.  
<img src="https://github.com/tfraczak/dungeon_crawler/blob/main/design_docs/dc_game_start.gif?raw=true" />  
Clean image of a starting room node.  
<img src="https://github.com/tfraczak/dungeon_crawler/blob/main/design_docs/dc3000.png?raw=true" />  
